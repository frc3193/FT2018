// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include <cscore_oo.h>
#include <CameraServer.h>
#include <Commands/Scheduler.h>
#include <DoubleSolenoid.h>
#include <Preferences.h>
#include <Robot.h>
#include <RobotBase.h>
#include <Servo.h>
#include <SmartDashboard/SendableChooser.h>
#include <SmartDashboard/SmartDashboard.h>
#include <Timer.h>
#include <memory>

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Chassis> Robot::chassis;
std::shared_ptr<Elevator> Robot::elevator;
std::shared_ptr<Intake> Robot::intake;
std::shared_ptr<Pressurizer> Robot::pressurizer;
std::shared_ptr<Ramp> Robot::ramp;
std::unique_ptr<OI> Robot::oi;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

Preferences* Robot::robotPref = 0;

void Robot::RobotInit() {
	RobotMap::init();
	robotPref = Preferences::GetInstance();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    chassis.reset(new Chassis());
    elevator.reset(new Elevator());
    intake.reset(new Intake());
    pressurizer.reset(new Pressurizer());
    ramp.reset(new Ramp());


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// Add commands to Autonomous Sendable Chooser
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	chooser.AddDefault("AutoTimedStraight", new AutoTimedStraight());
	chooser.AddObject("AutoCenter", new AutoCenter());
	chooser.AddObject("AutoDoNothing", new AutoDoNothing());
	chooser.AddObject("AutoGoStraight", new AutoGoStraight());
	chooser.AddObject("AutoLeft", new AutoLeft());
	chooser.AddObject("AutoRight", new AutoRight());
	//TODO: dont forget


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	SmartDashboard::PutData("Auto modes", &chooser);

	// Camera
	CameraServer::GetInstance()->StartAutomaticCapture(0);

	// Safely resetting the servos to the UPRIGHT or CLOSED position so that nothing carries over from previous rounds
	Robot::intake->servoLeft->Set(0.0);
	Robot::intake->servoRight->Set(1.0);

	// Setting the shifter to "Forward"
	Robot::chassis->shifter->Set(frc::DoubleSolenoid::Value::kForward);

	// Setting the ramp solenoids to upright on start
	Robot::ramp->left->Set(frc::DoubleSolenoid::Value::kForward);
	Robot::ramp->right->Set(frc::DoubleSolenoid::Value::kForward);
	Robot::ramp->deployer->Set(frc::DoubleSolenoid::Value::kForward);

	// Pref setting it up
	if (!Robot::robotPref->ContainsKey("timedStraightDuration")) {
		Robot::robotPref->PutDouble("timedStraightDuration", 3.5);
	}
}
/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){

}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();
}
void Robot::AutonomousInit() {
	Robot::chassis->timePref = Robot::robotPref->GetDouble("timedStraightDuration", 3.5);
	autonomousCommand.reset(chooser.GetSelected());
	//autonomousCommand.reset(new AutoGoStraight);
		if (autonomousCommand != nullptr)
			autonomousCommand->Start();

}

//int i = 0;

void Robot::AutonomousPeriodic() {
	frc::Scheduler::GetInstance()->Run();
	/*
	if(i < 100){
		Robot::chassis->leftA->Set(-0.5);
		Robot::chassis->leftB->Set(-0.5); //if there's more, you should add more. but we split 'em so it's all good as in: B = (B+C)
		Robot::chassis->rightA->Set(0.5);
		Robot::chassis->rightB->Set(0.5);
		i++;
	}
	else{
		Robot::chassis->leftA->Set(0.0);
		Robot::chassis->leftB->Set(0.0); //if there's more, you should add more. but we split 'em so it's all good as in: B = (B+C)
		Robot::chassis->rightA->Set(0.0);
		Robot::chassis->rightB->Set(0.0);

	}
	*/
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();


}

void Robot::TeleopPeriodic() {
	frc::Scheduler::GetInstance()->Run();
}

START_ROBOT_CLASS(Robot);

